* 2.1 Introduction to Data Abstraction
** 2.1.1 Example:Arithmetic Operations for Rational Numbers
** 2.1.2 Abstraction Barriers
   The horizontal lines represent *abstraction barriers* that isolate different "levels" of System.At each level, the barrier sperates the programs (above) that use the data abstraction from the programs (below) that implement the data abstration.
** 2.1.3 What is Meant by Data?
   In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.
   #+BEGIN_SRC scheme
     (define (cons x y)
       (define (dispatch m)
         (cond ((= m 0) x)
               ((= m 1) y)
               (else (error "Argument not 0 or 1: CONS" m))))
       dispatch)
     (define (car z) (z 0))
     (define (cdr z) (z 1))


   #+END_SRC
** 2.1.4 Extended Exercise: Interval Arithmetic

* 2.2 Hierarchical Data and the Closure Property 
  In this representation, which is called */box-and-pointer notation/*, each object is shown as a pointer to a box.
** 2.2.1 Representing Sequences
   One of the useful structures we can build with pairs is a *sequence*-an ordered collection of data objects.
   #+BEGIN_SRC scheme
     (cons 1
           (cons 2
                 (cons 3
                       (cons 4 nil))))

     (list <a1> <a2> ... <an>)
   #+END_SRC
   Such a sequence of pairs, formed by nested conses, is called a *list*, and Scheme provides a primitive called *list* to help constructing lists.
   In this representation, which is called *box-and-pointer notation*, each object is shown as a pointer to a box.
   The ability to create pairs whose elements are pairs is the essence of list structure's importance as a representational tool.We refer to this ability as the *closure property* of cons.In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.
** 2.2.1 Representing Sequences
   One of the useful structures we can build with pairs is a *sequence*-an ordered collection of data objects.
   #+BEGIN_SRC scheme
     (cons 1
           (cons 2
                 (cons 3
                       (cons 4 nil))))

     (list <a1> <a2> <a3> ... <an>)

     (define one-through-four (list 1 2 3 4))

     (cadr <arg>) = (car (cdr <arg>))

     (car one-through-four)
     1
     (cdr one-through-four)
     (2 3 4)
     (cons 10 one-through-four)
     (10 1 2 3 4)
   #+END_SRC

   List Operations
   #+BEGIN_SRC scheme
     (define (list-ref items n)
       (if (= n 0)
           (car items)
           (list-ref (cdr items) (- n 1))))
     (define squares (list 1 4 8 16 25))
     (list-ref squares 3)
     16


     (define (length items)
       (if (null? items)
           0
           (+ 1 (length (cdr items)))))
     (define odds (list 1 3 5 7))
     (length odds)
     4

     (define (length items)
       (define (length-iter a count)
         (if (null? a)
             count
             (length-iter (cdr a) (+ 1 count))))
       (length-iter items 0))

     (append squares odds)
     (1 4 9 16 25 1 3 5 7)

     (define (append list1 list2)
       (if (null? list1)
           list2
           (cons (car list1) (append (cdr list1) list2))))

   #+END_SRC

   Mapping over lists
   #+BEGIN_SRC scheme
     (define (scale-list items factor)
       (if (null? items)
           nil
           (cons (* (car items) factor)
                 (scale-list (cdr items)
                             factor))))
     (scale-list (list 1 2 3 4 5) 10)
     (10 20 30 40 50)

     (define (map proc items)
       (if (null? items)
           nil
           (cons (proc (car items))
                 (map proc (cdr items)))))
     (map abs (list -10 2.5 -11.6 17))
     (10 2.5 11.6 17)

     (define (scale-list items factor)
       (map (lambda (x) (* x factor))
            items))
   #+END_SRC
** 2.2.2 Hierarchical Structures
   The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences.
   Another way to think of sequences whose elements are sequences is as *trees*.The elements of the sequences are branches of the tree, and elements that are themselves sequences are subtrees.
   #+BEGIN_SRC scheme
     (define x (cons (list 1 2) (list 3 4)))
     (length x)
     3
     (count-leaves x)
     4
     (define (count-leaves x)
       (cond ((null? x) 0)
             ((not (pair? x)) 1)
             (else (+ (count-leaves (car x))
                      (count-leaves (cdr x))))))
   #+END_SRC
   Mapping over trees
   #+BEGIN_SRC scheme
     (define (scale-tree tree factor)
       (cond ((null? tree) nil)
             ((not (pair? tree)) (* tree factor))
             (else (cons (scale-tree (car tree) factor)
                         (scale-tree (cdr tree) factor)))))

     (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
     (10 (20 (30 40) 50) (60 70))

     (define (scale-tree tree factor)
       (map (lambda (sub-tree)
              (if (pair? sub-tree)
                  (scale-tree sub-tree factor)
                  (* sub-tree factor)))
            tree))
   #+END_SRC
** 2.2.3 Sequences as Conventional Interfaces
   #+BEGIN_SRC scheme
     (define (sum-odd-squares tree)
       (cond ((null? tree) 0)
             ((not (pair? tree))
              (if (odd? tree) (square tree) 0))
             (else (+ (sum-odd-squares (car tree))
                      (sum-odd-squares (cdr tree))))))

     (define (even-fibs n)
       (define (next k)
         (if (> k n)
             '()
             (let ((f (fib k)))
               (if (even? f)
                   (cons f (next (+ k 1)))
                   (next (+ k 1)))))
         (next 0)))

   #+END_SRC
   Unfortunately, the two procedure definitions above fail to exhibit this signal-flow structure.If we could organize our programs to make the signal-flow structure manifest in the procedures we write, this would increase the conceptual clarity of the resulting code.
   
   Sequence Operations
   The key to roganizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the "signals" that flow from one stage in the process to the next.If we represent these signals as list, then we can use list operations to implement the processing at each of the stages.
   #+BEGIN_SRC scheme
     (map square (list 1 2 3 4 5))
     (1 4 9 16 25)

     (define (filter predicate sequence)
       (cond ((null? sequence) '())
             ((predicate (car sequence))
              (cons (car sequence)
                    (filter predicate (cdr sequence))))
             (else (filter predicate (cdr sequence)))))

     (define (accumulate op initial sequence)
       (if (null? sequence)
           initial
           (op (car sequence)
               (accumulate op initial (cdr sequence)))))

     (define (enumerate-interval low high)
       (if (> low high)
           '()
           (cons low (enumerate-interval (+ low 1) high))))

     (define (enumerate-tree tree)
       (cond ((null? tree) '())
             ((not (pair? tree)) (list tree))
             (else (append (enumerate-tree (car tree))
                           (enumerate-tree (cdr tree))))))
     (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
     (1 2 3 4 5)

     (define (sum-odd-squares tree)
       (accumulate
        + 0 (map square (filter odd? (enumerate-tree tree)))))

     (define (even-fibs n)
       (accumulate
        cons
        '()
        (filter even? (map fib (enumerate-interval 0 n)))))
   #+END_SRC
   The value of expressing programs as sequence operations is that this help us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces.We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways.
   #+BEGIN_SRC scheme
     (define (list-fib-squares n)
       (accumulate
        cons
        '()
        (map squaare (map fib (enumerate-interval 0 n)))))
     (list-fib-squares 10)
     (0 1 1 4 9 25 64 169 441 1156 3025)

     (define (product-of-squares-of-odd-elements sequence)
       (accumulate * 1 (map squaare (filter odd? sequence))))
     (product-of-squares-of-odd-elements (list 1 2 3 4 5))
     225
   #+END_SRC
   
   Nested Mapping
   #+BEGIN_SRC scheme
     (accumulate
      append '() (map (lambda (i)
                        (map (lambda (j) (list i j))
                             (enumerate-interval 1 (- i 1))))
                      (enumerate-interval 1 n)))

     (define (flatmap proc seq)
       (accumulate append '() (map proc seq)))

     (define (prime-sum? pair)
       (prime? (+ (car pair) (cadr pair))))

     (define (make-pair-sum pair)
       (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

     (define (prime-sum-pairs n)
       (map make-pair-sum
            (filter prime-sum? (flatmap
                                (lambda (i)
                                  (map (lambda (j) (list i j))
                                       (enumerate-interval 1 (- i 1))))
                                (enumerate-interval 1 n)))))

     (define (permutations s)
       (if (null? s)
           (list '())
           (flatmap (lambda (x)
                      (map (lambda (p) (cons x p))
                           (permutations (remove x s))))
                    s)))

     (define (remove item sequence)
       (filter (lambda (x) (not (= x item)))
               sequence))
   #+END_SRC
** 2.2.4 Example: A Picture Language
*** The picture language
    When we began our study of programming in Section 1.1, we emphasized the importance of describing a language by focusing on the language's primitives, its means of combination, and its means of abstraction.We'll follow that framework here.
    #+BEGIN_SRC scheme
      (define wave2 (beside wave (flip-vert wave)))
      (define wave4 (below wave2 wave2))

      (define (flipped-pairs painter)
        (let ((painter2 (beside painter (flip-vert painter))))
          (below painter2 painter2)))

      (define wave4 (flipped-pairs wave))

      (define (right-split painter n)
        (if (= n 0)
            painter
            (let ((smaller (right-split painter (- n 1))))
              (beside painter (below smaller smaller)))))

      (define (corner-split painter n)
        (if (= n 0)
            painter
            (let ((up (up-split painter (- n 1)))
                  (right (right-split painter (- n 1))))
              (let ((top-left (beside up up))
                    (bottom-right (below right right))
                    (corner (corner-split painter (- n 1))))
                (beside (below painter top-left)
                        (below bottom-right corner))))))

      (define (square-limit painter n)
        (let ((quarter (corner-split painter n)))
          (let ((half (beside (flip-horiz quarter) quarter)))
            (below (flip-vert half) half))))
    #+END_SRC
*** Higher-order operations
    In addition to abstracting patterns of combining painters, we can work at a higher level, abstracting patterns of combining painter operations.That is, we can view the painter operations as elements to manipulate and can write means of combination for these elements-procedures that take painter operations as arguments and create new painter operations.
    #+BEGIN_SRC scheme
      (define (square-of-four tl tr bl br)
        (lambda (painter)
          (let ((top (beside (tl painter) (tr painter)))
                (bottom (beside (bl painter) (br painter))))
            (below bottom top))))

      (define (flipped-pairs painter)
        (let ((combine4 (square-of-four identity flip-vert
                                        identity flip-vert)))
          (combine4 painter)))

      (define (square-limit painter n)
        (let ((combine4 (square-of-four flip-horiz identity
                                        rotate180 flip-vert)))
          (combine4 (corner-split painter n))))
    #+END_SRC
*** Frames
    A frame can be described by three vectors-an origin vector and two edge vectors.
    #+BEGIN_SRC scheme
      (define (frame-coord-map frame)
        (lambda (v)
          (add-vect
           (origin-frame frame)
           (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
                     (scale-vect (ycor-vect v) (edge2-frame frame))))))

      ((frame-coord-map a-frame) (make-vect 0 0))

      (origin-frame a-frame)
    #+END_SRC
*** Painters
    A painter is represented as a procedure that, given a frame as argument, draws a particular image shifted and scaled to fit the frame.
    #+BEGIN_SRC scheme
      (define (segments->painter segment-list)
        (lambda (frame)
          (for-each
           (lambda (segment)
             (draw-line
              ((frame-coord-map frame)
               (start-segment segment))
              ((frame-coord-map frame)
               (end-segment segment))))
           segment-list)))
    #+END_SRC
    Representing painters as procedures erects a powerful abstration barrier in the picture language.We can create and intermix all sorts of primitive painters, based on a variety of graphics capabilities.The details of their implementation do not matter.
*** Transforming and combining painter
    Thus, for example, flip-vert doesn't have to know how a painter works in order to flip it-it just has to know how to turn a frame upside down:The flipped painter just uses the original painter, but in the inverted frame.
    #+BEGIN_SRC scheme
      (define (transform-painter painter origin corner1 corner2)
        (lambda (frame)
          (let ((m (frame-coord-map frame)))
            (let ((new-origin (m origin)))
              (painter (make-frame
                        new-origin
                        (sub-vect (m corner1) new-origin)
                        (sub-vect (m corner2) new-origin)))))))

      (define (flip-vert painter)
        (transform-painter painter
                           (make-vect 0.0 1.0) ; new origin
                           (make-vect 1.0 1.0) ; new end of edge1
                           (make-vect 0.0 0.0))) ; new end of edge2

      (define (shrink-to-upper-right painter)
        (transform-painter
         painter (make-vect 0.5 0.5)
         (make-vect 1.0 0.5) (make-vect 0.5 1.0)))

      (define (rotate90 painter)
        (transform-painter painter
                           (make-vect 1.0 0.0)
                           (make-vect 1.0 1.0)
                           (make-vect 0.0 0.0)))

      (define (squash-inwards painter)
        (transform-painter painter
                           (make-vect 0.0 0.0)
                           (make-vect 0.65 0.35)
                           (make-vect 0.35 0.65)))
    #+END_SRC
    Frame transformation is also the key to defining means of combining two or more painters.
    #+BEGIN_SRC scheme
      (define (beside painter1 painter2)
        (let ((split-point (make-vect 0.5 0.0)))
          (let ((paint-left
                 (transform-painter
                  painter1
                  (make-vect 0.0 0.0)
                  split-point
                  (make-vect 0.0 1.0)))
                (paint-right
                 (transform-painter
                  painter2
                  split-point
                  (make-vect 1.0 0.0)
                  (make-vect 0.5 1.0))))
            (lambda (frame)
              (paint-left frame)
              (paint-right frame)))))
    #+END_SRC
    The beside procedure need not know anything about the details of the component painters other than that each painter will draw something in its designated frame.
*** Levels of language for robust design
    The means of combination satisfy the closure property, which permits us to easily build up complex designs.Finally, all the tools for abstracting procedures are available to us for abstracting means of combination for painters.
    This is approach of *statified design*, the notion that a complex system should be structured as a sequence of levels that are described using a sequence of languages.Each level is constructed by combining parts that are regarded as primitives at the next level.
    Stratified design helps make program *robust*, that is, it makes it likely that small changes in a specification will require correspondingly small changes in the program
* 2.3 Sybolic Data
  In this section we extend the presentational capability of our language by introducing the ability to work with arbitrary symbols as data.
** 2.3.1 Quatation
   In order to manipulate symbols we need a new element in our language: the ability to *quote* a data object. 
   #+BEGIN_SRC scheme
     (define a 1)

     (define b 2)

     (list a b)
     (1 2)

     (list 'a 'b)
     (a b)

     (list 'a b)
     (a 2)

     (car '(a b c))
     a

     (cdr '(a b c))
     (b c)

     (define (memq item x)
       (cond ((null? x) false)
             ((eq? item (car x) x))
             (else (memq item (cdr x)))))

     (memq 'apple '(pear banana prune))
     false

     (memq 'apple '(x (apple sauce) y apple pear))
     (apple pear)
   #+END_SRC
** 2.3.2 Example: Symbolic Differentiation
   We would lick the procedure to take as arguments an algebraic expression and a variable and to return the derivative of the expression with respect to the variable.
*** The differentiation program with abstract data 
    #+BEGIN_SRC scheme
      (variable? e) ;; Is e a variable?
      (same-vaiable? v1 v2) ;; Are v1 and v2 the same variable?
      (sum? e) ;; Is e a sum?
      (addend e) ;; Addend of the sum e.
      (augend e) ;; Augend of the sum e.
      (make-sum a1 a2) ;; Construct the sum of a1 and a2.
      (product? e) ;; Is e a product?
      (multiplier e) ;; Multiplier of the product e.
      (multiplicand e) ;; Multiplicand of the product e.
      (make-product m1 m2) ;; Construct the product of m1 and m2.

      (define (deriv exp var)
        (cond ((number? exp) 0)
              ((variable? exp) (if (same-vaiable? exp var)
                                   1
                                   0))
              ((sum? exp) (make-sum (deriv (addend exp) var)
                                    (deriv (augend exp) var)))
              ((product? exp)
               (make-sum
                (make-product (multiplier exp)
                              (deriv (multiplicand exp) var))
                (make-product (multiplicand exp)
                              (deriv (multiplier exp) var))))
              (else
               (error "unknown expression type: DERIV" exp))))
    #+END_SRC
    This *deriv* procedure incorporates the complete differentiation algorithm. Since it is expressed in terms of abstract data, it will work no matter how we choose to represent algebraic expressions, as long as we design a proper set of selectors and constructors.
*** Representing algebraic expressions
    However, one especially straightforward choice is to use the same parenthesized prefix notation that Lisp uses for combinations; that is, to represent ax + b as (+ (* a x) b). 
    #+BEGIN_SRC scheme
      (define (variable? x) (symbol? x))

      (define (same-variable? v1 v2)
        (and (variable? v1)
             (variable? v2)
             (eq? v1 v2)))

      (define (make-sum a1 a2)
        (list '+ a1 a2))

      (define (make-product m1 m2)
        (list '* m1 m2))

      (define (sum? x)
        (and (pair? x)
             (eq? (car x) '+)))

      (define (addend s)
        (cadr s))

      (define (augend s)
        (caddr s))

      (define (product? x)
        (and (pair? x)
             (eq? (car x) '*)))

      (define (multiplier p)
        (cadr p))

      (define (multiplicand p)
        (caddr p))
    #+END_SRC
    To accomplish the rational-number reduction, we needed to change only the constructors and the selectors of the implementation.
    #+BEGIN_SRC scheme
      (define (make-sum a1 a2)
        (cond ((=number? a1 0) a2)
              ((=number? a2 0) a1)
              ((and (number? a1) (number? a2))
               (+ a1 a2))
              (else (list '+ a1 a2))))

      (define (=number? exp num)
        (and (number? exp)
             (= exp num)))

      (define (make-product m1 m2)
        (cond ((or (=number? m1 0) (=number? m2)) 0)
              ((=number? m1 1) m2)
              ((=number? m2 1) m1)
              ((and (number? m1) (number? m2))
               (* m1 m2))
              (else (list '* m1 m2))))
    #+END_SRC
** 2.3.2 Example: Representing Sets
   That is, we define "set" by specifying the operations that are to be used on sets.These are *union-set*, *intersection-set*, *element-of-set?*, and *adjoin-set*.
*** Sets as unordered lists
    #+BEGIN_SRC scheme
      (define (element-of-set? x set)
        (cond ((null? set) false)
              ((equal? x (car set)) true)
              (else (element-of-set? x (cdr set)))))

      (define (adjoin-set x set)
        (if (element-of-set? x set)
            set
            (cons x set)))

      (define (intersection-set set1 set2)
        (cond ((or (null? set1) (null? set2)) '())
              ((element-of-set? (car set1) set2)
               (cons (car set1) (intersection-set (cdr set1) set2)))
              (else (intersection-set (cdr set1) set2))))
    #+END_SRC
*** Sets as ordered lists
    #+BEGIN_SRC scheme
      (define (element-of-set? x set)
        (cond ((null? set) false)
              ((= x (car set)) true)
              ((< x (car set)) false)
              (else (element-of-set? x (cdr set)))))

      (define (intersection-set set1 set2)
        (if (or (null? set1) (null? set2))
            '()
            (let ((x1 (car set1)) (x2 (car set2)))
              (cond ((= x1 x2)
                     (cons x1 (intersection-set (cdr set1)
                                                (cdr set2))))
                    ((< x1 x2)
                     (intersection-set (cdr set1) set2))
                    ((< x2 x1)
                     (intersection-set set1 (cdr set2)))))))
    #+END_SRC
*** Sets as binary trees
    #+BEGIN_SRC scheme
      (define (make-tree entry left right)
        (list entry left right))

      (define (entry tree)
        (car tree))

      (define (left-branch tree)
        (cadr tree))

      (define (right-branch tree)
        (caddr tree))

      (define (element-of-set? x set)
        (cond ((null? set) false)
              ((= x (entry set)) true)
              ((< x (entry set))
               (element-of-set? x (left-branch set)))
              ((> x (entry set))
               (element-of-set? x (right-branch set)))))

      (define (adjoin-set x set)
        (cond ((null? set) (make-tree x '() '()))
              ((= x (entry set))
               set)
              ((< x (entry set))
               (make-tree (entry set)
                          (adjoin-set x (left-branch set))
                          (right-branch set)))
              ((> x (entry set))
               (make-tree (entry set)
                          (left-branch set)
                          (adjoin-set x (right-branch set))))))
    #+END_SRC
*** Sets and information retrieval
    #+BEGIN_SRC scheme
      (define (lookup given-key set-of-records)
        (cond ((null? set-of-records) false)
              ((equal? given-key (key (car set-of-records)))
               (car set-of-records))
              (else (lookup given-key (cdr set-of-records)))))

    #+END_SRC
** 2.3.4 Exaple: Huffman Encoding Trees
   Codes such as ASCII and the A-through-H (A 000 B 001 C 010) code above are known as *fixed-length* codes.It is sometimes advantageous to use *variable-length* codes, in which diffrent symbols may be represented by different numbers of bits(A 0 B 100 C 1010).
   One of the difficulties of using a variable-length code is knowing when you have reached the end of a symbol in reading a sequence of zeros and ones. Morse code solves this problem by using a special *separator code* (in this case, a pause) after the sequence of dots and dashes for each letter. Another solution is to design the code in such a way that no complete code for any symbol is beginning (or prefix) of th code for another symbol.Such a code is called a *prefix code*. 
*** Generating Huffman trees
    The idea is to arrange the tree so that the symbols with the lowest frequency appear farthest away from the root. Begin with the set of leaf nodes, containing symblos and their frequencies, as determined by the initial data from which the code is to be constructed. Now find two leaves with the lowest weights and merge them to produce a node that has these two nodes as its left and right branches. The weight of the new node is the sum of the two weights. Remove the two leaves from the original set and replace them by this new node. Now continue this process. At each step, merge two nodes with the smallest weights, removing them from the set and replacing them with a node that has these two as its left and right branches. The process stops when there is only one node left, which is the root of the entire tree. Here is how the Huffman tree of Figure 2.18 was generated:
    Initial leaves {(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}
             Merge {(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}
             Merge {(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}
             Merge {(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}
             Merge {(A 8) (B 3) ({C D} 2) ({E F G H} 4)}
             Merge {(A 8) ({B C D} 5) ({E F G H} 4)}
             Merge {(A 8) ({B C D E F G H} 9)}
       Final Merge {{A B C D E F G H} 17)}
*** Representing Huffman trees
    #+BEGIN_SRC scheme :tangle HuffmanTree.scm
      (define (make-leaf symbol weight) (list 'leaf symbol weight))

      (define (leaf? object) (eq? (car object) 'leaf))

      (define (symbol-leaf x) (cadr x))

      (define (weight-leaf x) (caddr x))

      (define (make-code-tree left right)
        (list left
              right
              (append (symbols left) (symbols right))
              (+ (weight left) (weight right))))

      (define (left-branch tree) (car tree))

      (define (right-branch tree) (cadr tree))

      (define (symbols tree)
        (if (leaf? tree)
            (list (symbol-leaf tree))
            (caddr tree)))

      (define (weight tree)
        (if (leaf? tree)
            (weight-leaf tree)
            (cadddr tree)))

    #+END_SRC
    The procedures *symbols* and *weight* must do something slightly different depending on whether they are called with a leaf or a general tree. These are simple example of *generic procedures* (procedures that can handle more than one kind of data), which we will have much more to say about in Section 2.4 and Section 2.5.
*** The decoding procedure
    #+BEGIN_SRC scheme :tangle HuffmanTree.scm
      (define (decode bits tree)
        (define (decode-1 bits current-branch)
          (if (null? bits)
              '()
              (let ((next-branch
                     (choose-branch (car bits) current-branch)))
                (if (leaf? next-branch)
                    (cons (symbol-leaf next-branch)
                          (decode-1 (cdr bits) tree))
                    (decode-1 (cdr bits) next-branch)))))
        (decode-1 bits tree))

      (define (choose-branch bit branch)
        (cond ((= bit 0) (left-branch branch))
              ((= bit 1) (right-branch branch))
              (else (error "bad bit: CHOOSE-BRANCH" bit))))
    #+END_SRC
*** Sets of weighted elements
    #+BEGIN_SRC scheme :tangle HuffmanTree.scm
      (define (adjoin-set x set)
        (cond ((null? set) (list x))
              ((< (weight x) (weight (car set))) (cons x set))
              (else (cons (car set)
                          (adjoin-set x (cdr set))))))

      (define (make-leaf-set pairs)
        (if (null? pairs)
            '()
            (let ((pair (car pairs)))
              (adjoin-set (make-leaf (car pair) ; symbol
                                     (cadr pair)) ; frequency
                          (make-leaf-set (cdr pairs))))))
    #+END_SRC
* 2.4 Multiple Representations for Abstract Data
  We have introduced data abstraction, a methodology for structuring systems in such a way that much of a program can be specified independent of the choices involved in implementing the data objects that the program manipulates.
  These data-abstraction barriers are powerful tools for controlling complexity. By isolating the underlying representations of data objects, we can divide the task of designing a large program into smaller tasks that can be performed separately. But this kind of data abstraction is not yet powerful enough, because it may not always make sense to speak of "the underlying representation" for a data object.
  For one thing, there might be more than one useful representation for a data object, and we might like to design systems that can deal with multiple representations.
  Furthermore, since large programs are often created by combining pre-existing modules that were designed in isolation, we need conventions that permit programmers to incorporate modules into larger system *additively*, that is, without having to redesign or reimplement these modules.
  In this section, we will learn how to cope with data that may be represented in different ways by different parts of a program. This requires constructing *generic procedures*-procedures that can operate on data that may be represented in more than one way. Our main technique for building generic procedures will be to work in terms of data objects that have *type tags*, that is, data objects that include explicit information about how they are to be processed.We will also discuss *data-directed* programming, a powerful and convenient implementation strategy for additively assembling systems with generic operations.
** 2.4.1 Representations for Complex Numbers
   Manipulates
   #+BEGIN_SRC scheme
     (make-from-real-img (real-part z) (imag-part z))

     (make-from-mag-ang (magnitude z) (angle z))

     (define (add-complex z1 z2)
       (make-from-real-img (+ (real-part z1) (real-part z2))
                           (+ (imag-part z1) (imag-part z2))))

     (define (sub-complex z1 z2)
       (make-from-real-img (- (real-part z1) (real-part z2))
                           (- (imag-part z1) (imag-part z2))))

     (define (mul-complex z1 z2)
       (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                          (+ (angle z1) (angle z2))))

     (define (div-complex z1 z2)
       (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                          (- (angle z1) (angle z2))))
   #+END_SRC
   Rectangular form
   #+BEGIN_SRC scheme
     (define (real-part z) (car z))

     (define (imag-part z) (cdr z))

     (define (magnitude z)
       (sqrt (+ (square (real-part z))
                (square (imag-part z)))))

     (define (angle z)
       (atan (imag-part z) (real-part z)))

     (define (make-from-real-imag x y) (cons x y))

     (define (make-from-mag-ang r a)
       (cons (* r (cos a)) (* r (sin a))))

   #+END_SRC
   Polar form
   #+BEGIN_SRC scheme 
     (define (magnitude z) (car z))

     (define (angle z) (cdr z))

     (define (real-part z) (* (magnitude z) (cos (angle z))))

     (define (imag-part z) (* (magnitude z) (sin (angle z))))

     (define (make-from-real-imag x y)
       (cons (sqrt (+ (square x) (square y)))
             (atan y x)))

     (define (make-from-mag-ang r a)
       (cons r a))

   #+END_SRC 
   The discipline of data abstraction ensures that the same implementation of manipulates will work either rectangular form or polar form.
** 2.4.2 Tagged data
   A straightforward way to accomplish this distinction is to include a *type tag*-the symbol *rectangular* or *polar*-as part of each complex number.The when we need to manipulate a complex number we can use the tag to decide which selector to apply.
   In order to manipulate tagged data, we will assume that we have procedures *type-tag* and *contents* that extract from a data object the tag and the actual contents(the polar or rectangular coordinates, in the case of a complex number). We will also postulate a procedure *attach-tag* that takes a tag and contents and produces a tagged data object.
   #+BEGIN_SRC scheme
     (define (attach-tag type-tag contents)
       (cons type-tag contents))

     (define (type-tag datum)
       (if (pair? datum)
           (car datum)
           (error "Bad tagged datum: TYPE-TAG" datum)))

     (define (contents datum)
       (if (pair? datum)
           (cdr datum)
           (error "Bad tagged datum: CONTENTS" datum)))

     (define (rectangular? z)
       (eq? (type-tag z) 'rectangular))

     (define (polar? z)
       (eq? (type-tag z) 'polar))

     (define (real-part-rectangular z) (car z))

     (define (imag-part-rectangular z) (cdr z))

     (define (magnitude-rectangular z)
       (sqrt (+ (square (real-part-rectangular))
                (square (imag-part-rectangular)))))

     (define (angle-rectangular z)
       (atan (imag-part-rectangular z)
             (real-part-rectangular z)))

     (define (make-from-real-imag-rectangular x y)
       (attach-tag 'rectangular (cons x y)))

     (define (make-from-mag-ang-rectangular r a)
       (attach-tag 'rectangular
                   (cons (* r (cos a)) (* r (sin a)))))

     (define (real-part-polar z)
       (* (magnitude-polar z) (cos (angle-polar z))))

     (define (imag-part-polar z)
       (* (magnitude-polar z) (sin (angle-polar z))))

     (define (magnitude-polar z) (car z))

     (define (angle-polar z) (cdr z))

     (define (make-from-real-imag-polar x y)
       (attach-tag 'polar
                   (cons (sqrt (+ (square x) (square y)))
                         (atan y x))))

     (define (real-part z)
       (cond ((rectangular? z)
              (real-part-rectangular (contents z)))
             ((polar? z)
              (real-part-polar (contents z)))
             (else (error "Unknown type: REAL-PART" z))))

     (define (imag-part z)
       (cond ((rectangular? z)
              (imag-part-rectangular (contents z)))
             ((polar? z)
              (imag-part-polar (contents z)))
             (else (error "Unknown type: IMAG-PART" z))))

     (define (magnitude z)
       (cond ((rectangular? z)
              (magnitude-rectangular (contents z)))
             ((polar? z)
              (magnitude-polar (contents z)))
             (else (error "Unknown type: MAGNITUDE" z))))

     (define (angle z)
       (cond ((rectangular? z)
              (angle-rectangular (contents z)))
             ((polar? z)
              (angle-polar (contents z)))
             (else (error "Unknown type: ANGLE" z))))
   #+END_SRC
** 2.4.3 Data-Directed Programming and Additivity
   The general strategy of checking the type of a datum and calling an appropriate procedure is called *dispatching on type*. This is a powerful stategy for obtaining modularity in system design. On the other hand, implementing the dispatch as in section 2.4.2 has tow significant weaknesses. One weakness is that the generic interface procedures (real-part, imag-part, magnitude, and angle) must know about all the different representations. Another weakness of the technique is that even though the individual representations can be designed separately, we must guarantee that no two procedures in the entire system have the same name.
   The issue underlying both of these weaknesses is that the technique for implementing generic interfaces is not *additive*.
   What we need is a means for modularizing the system design even further.This is provided by the programming technique known as *data-directed programming*.
   Data-directed programming is the technique of designing programs to work with such a table directly.Previously, we implemented the mechanism that interfaces the complex-arithmetic code with the two representation packages as a set of procedures that each perform an explicit dispatch on type. Here we will implement the interface as a single procedure that looks up the combination of the operation name and argument type in the table to find the correct procedure to apply, and then applies it to the contents of the argument.
   To implement this plan, assume that we have two procedures, *put* and *get*, for manipulating the operation-and-type table:
   - (put <op> <type> <item>) installs the <item> in the table, indexed by the <op> and the <type>.
   - (get <op> <type>) looks up the <op>, <type> entry in the table and returns the item found there. If no item is found, get returns false.
     
   #+BEGIN_SRC scheme
     (define (install-rectangular-package)
       ;; internal procedures
       (define (real-part z) (car z))
       (define (imag-part z) (cdr z))
       (define (make-from-real-imag x y) (cons x y))
       (define (magnitude z)
         (sqrt (+ (square (real-part z))
                  (square (imag-part z)))))
       (define (angle z)
         (atan (imag-part z) (real-part z)))
       (define (make-from-mag-ang r a)
         (cons (* r (cos a)) (* r (sin a))))

       ;; interface to the rest of the system
       (define (tag x) (attach-tag 'rectangular x))
       (put 'real-part '(rectangular) real-part)
       (put 'imag-part '(rectangular) real-part)
       (put 'magnitude '(rectangular) magnitude)
       (put 'angle '(rectangular) angle)
       (put 'make-from-real-imag 'rectangular
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'rectangular
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)

     (define (install-polar-package)
       ;; internal procedures
       (define (magnitude z) (car z))
       (define (angle z) (cdr z))
       (define (make-from-mag-ang r a) (cons r a))
       (define (real-part z) (* (magnitude z) (cos (angle z))))
       (define (imag-part z) (* (magnitude z) (sin (angle z))))
       (define (make-from-real-imag x y)
         (cons (sqrt (+ (square x) (square y)))
               (atan y x)))

       ;; interface to the rest of the system
       (define (tag x) (attach-tag 'polar x))
       (put 'real-part '(polar) real-part)
       (put 'imag-part '(polar) imag-part)
       (put 'magnitude '(polar) magnitude)
       (put 'angle '(polar) angle)
       (put 'make-from-real-imag 'polar
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'polar
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)
   #+END_SRC
   The complex-arithmetic selectors access the table by means of a general "operation" procedure called *apply-generic*, which applies a generic operation to some arguments.
   #+BEGIN_SRC scheme
     (define (apply-generic op . args)
       (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
           (if proc
               (apply proc (map contents args))
               (error
                "No method for these types: APPLY_GENERIC"
                (list op type-tags))))))

     (define (real-part z) (apply-generic 'real-part z))

     (define (imag-part z) (apply-generic 'imag-part z))

     (define (magnitude z) (apply-generic 'magnitude z))

     (define (angle z) (apply-generic 'angle z))

     (define (make-from-real-imag x y)
       ((get 'make-from-real-imag 'rectangular) x y))

     (define (make-from-mag-ang r a)
       ((get 'make-from-mag-ang 'polar) r a))
   #+END_SRC
