* 2.1 Introduction to Data Abstraction
** 2.1.1 Example:Arithmetic Operations for Rational Numbers
** 2.1.2 Abstraction Barriers
   The horizontal lines represent *abstraction barriers* that isolate different "levels" of System.At each level, the barrier sperates the programs (above) that use the data abstraction from the programs (below) that implement the data abstration.
** 2.1.3 What is Meant by Data?
   In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.
   #+BEGIN_SRC scheme
     (define (cons x y)
       (define (dispatch m)
         (cond ((= m 0) x)
               ((= m 1) y)
               (else (error "Argument not 0 or 1: CONS" m))))
       dispatch)
     (define (car z) (z 0))
     (define (cdr z) (z 1))


   #+END_SRC
** 2.1.4 Extended Exercise: Interval Arithmetic

* 2.2 Hierarchical Data and the Closure Property 
  In this representation, which is called */box-and-pointer notation/*, each object is shown as a pointer to a box.
** 2.2.1 Representing Sequences
   One of the useful structures we can build with pairs is a *sequence*-an ordered collection of data objects.
   #+BEGIN_SRC scheme
     (cons 1
           (cons 2
                 (cons 3
                       (cons 4 nil))))

     (list <a1> <a2> ... <an>)
   #+END_SRC
   Such a sequence of pairs, formed by nested conses, is called a *list*, and Scheme provides a primitive called *list* to help constructing lists.
   In this representation, which is called *box-and-pointer notation*, each object is shown as a pointer to a box.
   The ability to create pairs whose elements are pairs is the essence of list structure's importance as a representational tool.We refer to this ability as the *closure property* of cons.In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.
** 2.2.1 Representing Sequences
   One of the useful structures we can build with pairs is a *sequence*-an ordered collection of data objects.
   #+BEGIN_SRC scheme
     (cons 1
           (cons 2
                 (cons 3
                       (cons 4 nil))))

     (list <a1> <a2> <a3> ... <an>)

     (define one-through-four (list 1 2 3 4))

     (cadr <arg>) = (car (cdr <arg>))

     (car one-through-four)
     1
     (cdr one-through-four)
     (2 3 4)
     (cons 10 one-through-four)
     (10 1 2 3 4)
   #+END_SRC

   List Operations
   #+BEGIN_SRC scheme
     (define (list-ref items n)
       (if (= n 0)
           (car items)
           (list-ref (cdr items) (- n 1))))
     (define squares (list 1 4 8 16 25))
     (list-ref squares 3)
     16


     (define (length items)
       (if (null? items)
           0
           (+ 1 (length (cdr items)))))
     (define odds (list 1 3 5 7))
     (length odds)
     4

     (define (length items)
       (define (length-iter a count)
         (if (null? a)
             count
             (length-iter (cdr a) (+ 1 count))))
       (length-iter items 0))

     (append squares odds)
     (1 4 9 16 25 1 3 5 7)

     (define (append list1 list2)
       (if (null? list1)
           list2
           (cons (car list1) (append (cdr list1) list2))))

   #+END_SRC

   Mapping over lists
   #+BEGIN_SRC scheme
     (define (scale-list items factor)
       (if (null? items)
           nil
           (cons (* (car items) factor)
                 (scale-list (cdr items)
                             factor))))
     (scale-list (list 1 2 3 4 5) 10)
     (10 20 30 40 50)

     (define (map proc items)
       (if (null? items)
           nil
           (cons (proc (car items))
                 (map proc (cdr items)))))
     (map abs (list -10 2.5 -11.6 17))
     (10 2.5 11.6 17)

     (define (scale-list items factor)
       (map (lambda (x) (* x factor))
            items))
   #+END_SRC
** 2.2.2 Hierarchical Structures
   The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences.
   Another way to think of sequences whose elements are sequences is as *trees*.The elements of the sequences are branches of the tree, and elements that are themselves sequences are subtrees.
   #+BEGIN_SRC scheme
     (define x (cons (list 1 2) (list 3 4)))
     (length x)
     3
     (count-leaves x)
     4
     (define (count-leaves x)
       (cond ((null? x) 0)
             ((not (pair? x)) 1)
             (else (+ (count-leaves (car x))
                      (count-leaves (cdr x))))))
   #+END_SRC
   Mapping over trees
   #+BEGIN_SRC scheme
     (define (scale-tree tree factor)
       (cond ((null? tree) nil)
             ((not (pair? tree)) (* tree factor))
             (else (cons (scale-tree (car tree) factor)
                         (scale-tree (cdr tree) factor)))))

     (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
     (10 (20 (30 40) 50) (60 70))

     (define (scale-tree tree factor)
       (map (lambda (sub-tree)
              (if (pair? sub-tree)
                  (scale-tree sub-tree factor)
                  (* sub-tree factor)))
            tree))
   #+END_SRC
** 2.2.3 Sequences as Conventional Interfaces
   #+BEGIN_SRC scheme
     (define (sum-odd-squares tree)
       (cond ((null? tree) 0)
             ((not (pair? tree))
              (if (odd? tree) (square tree) 0))
             (else (+ (sum-odd-squares (car tree))
                      (sum-odd-squares (cdr tree))))))

     (define (even-fibs n)
       (define (next k)
         (if (> k n)
             '()
             (let ((f (fib k)))
               (if (even? f)
                   (cons f (next (+ k 1)))
                   (next (+ k 1)))))
         (next 0)))

   #+END_SRC
   Unfortunately, the two procedure definitions above fail to exhibit this signal-flow structure.If we could organize our programs to make the signal-flow structure manifest in the procedures we write, this would increase the conceptual clarity of the resulting code.
   
   Sequence Operations
   The key to roganizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the "signals" that flow from one stage in the process to the next.If we represent these signals as list, then we can use list operations to implement the processing at each of the stages.
   #+BEGIN_SRC scheme
     (map square (list 1 2 3 4 5))
     (1 4 9 16 25)

     (define (filter predicate sequence)
       (cond ((null? sequence) '())
             ((predicate (car sequence))
              (cons (car sequence)
                    (filter predicate (cdr sequence))))
             (else (filter predicate (cdr sequence)))))

     (define (accumulate op initial sequence)
       (if (null? sequence)
           initial
           (op (car sequence)
               (accumulate op initial (cdr sequence)))))

     (define (enumerate-interval low high)
       (if (> low high)
           '()
           (cons low (enumerate-interval (+ low 1) high))))

     (define (enumerate-tree tree)
       (cond ((null? tree) '())
             ((not (pair? tree)) (list tree))
             (else (append (enumerate-tree (car tree))
                           (enumerate-tree (cdr tree))))))
     (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
     (1 2 3 4 5)

     (define (sum-odd-squares tree)
       (accumulate
        + 0 (map square (filter odd? (enumerate-tree tree)))))

     (define (even-fibs n)
       (accumulate
        cons
        '()
        (filter even? (map fib (enumerate-interval 0 n)))))
   #+END_SRC
   The value of expressing programs as sequence operations is that this help us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces.We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways.
   #+BEGIN_SRC scheme
     (define (list-fib-squares n)
       (accumulate
        cons
        '()
        (map squaare (map fib (enumerate-interval 0 n)))))
     (list-fib-squares 10)
     (0 1 1 4 9 25 64 169 441 1156 3025)

     (define (product-of-squares-of-odd-elements sequence)
       (accumulate * 1 (map squaare (filter odd? sequence))))
     (product-of-squares-of-odd-elements (list 1 2 3 4 5))
     225
   #+END_SRC
   
