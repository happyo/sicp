* 2.1 Introduction to Data Abstraction
** 2.1.1 Example:Arithmetic Operations for Rational Numbers
** 2.1.2 Abstraction Barriers
   The horizontal lines represent *abstraction barriers* that isolate different "levels" of System.At each level, the barrier sperates the programs (above) that use the data abstraction from the programs (below) that implement the data abstration.
** 2.1.3 What is Meant by Data?
   In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.
   #+BEGIN_SRC scheme
     (define (cons x y)
       (define (dispatch m)
         (cond ((= m 0) x)
               ((= m 1) y)
               (else (error "Argument not 0 or 1: CONS" m))))
       dispatch)
     (define (car z) (z 0))
     (define (cdr z) (z 1))


   #+END_SRC
** 2.1.4 Extended Exercise: Interval Arithmetic

* 2.2 Hierarchical Data and the Closure Property 
  In this representation, which is called */box-and-pointer notation/*, each object is shown as a pointer to a box.
** 2.2.1 Representing Sequences
   One of the useful structures we can build with pairs is a *sequence*-an ordered collection of data objects.
   #+BEGIN_SRC scheme
     (cons 1
           (cons 2
                 (cons 3
                       (cons 4 nil))))

     (list <a1> <a2> ... <an>)
   #+END_SRC
   Such a sequence of pairs, formed by nested conses, is called a *list*, and Scheme provides a primitive called *list* to help constructing lists.
   In this representation, which is called *box-and-pointer notation*, each object is shown as a pointer to a box.
   The ability to create pairs whose elements are pairs is the essence of list structure's importance as a representational tool.We refer to this ability as the *closure property* of cons.In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.
** 2.2.1 Representing Sequences
   One of the useful structures we can build with pairs is a *sequence*-an ordered collection of data objects.
   #+BEGIN_SRC scheme
     (cons 1
           (cons 2
                 (cons 3
                       (cons 4 nil))))

     (list <a1> <a2> <a3> ... <an>)

     (define one-through-four (list 1 2 3 4))

     (cadr <arg>) = (car (cdr <arg>))

     (car one-through-four)
     1
     (cdr one-through-four)
     (2 3 4)
     (cons 10 one-through-four)
     (10 1 2 3 4)
   #+END_SRC

   List Operations
   #+BEGIN_SRC scheme
     (define (list-ref items n)
       (if (= n 0)
           (car items)
           (list-ref (cdr items) (- n 1))))
     (define squares (list 1 4 8 16 25))
     (list-ref squares 3)
     16


     (define (length items)
       (if (null? items)
           0
           (+ 1 (length (cdr items)))))
     (define odds (list 1 3 5 7))
     (length odds)
     4

     (define (length items)
       (define (length-iter a count)
         (if (null? a)
             count
             (length-iter (cdr a) (+ 1 count))))
       (length-iter items 0))

     (append squares odds)
     (1 4 9 16 25 1 3 5 7)

     (define (append list1 list2)
       (if (null? list1)
           list2
           (cons (car list1) (append (cdr list1) list2))))

   #+END_SRC

   Mapping over lists
   #+BEGIN_SRC scheme
     (define (scale-list items factor)
       (if (null? items)
           nil
           (cons (* (car items) factor)
                 (scale-list (cdr items)
                             factor))))
     (scale-list (list 1 2 3 4 5) 10)
     (10 20 30 40 50)

     (define (map proc items)
       (if (null? items)
           nil
           (cons (proc (car items))
                 (map proc (cdr items)))))
     (map abs (list -10 2.5 -11.6 17))
     (10 2.5 11.6 17)

     (define (scale-list items factor)
       (map (lambda (x) (* x factor))
            items))
   #+END_SRC
** 2.2.2 Hierarchical Structures
   The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences.
   Another way to think of sequences whose elements are sequences is as *trees*.The elements of the sequences are branches of the tree, and elements that are themselves sequences are subtrees.
   #+BEGIN_SRC scheme
     (define x (cons (list 1 2) (list 3 4)))
     (length x)
     3
     (count-leaves x)
     4
     (define (count-leaves x)
       (cond ((null? x) 0)
             ((not (pair? x)) 1)
             (else (+ (count-leaves (car x))
                      (count-leaves (cdr x))))))
   #+END_SRC
   Mapping over trees
   #+BEGIN_SRC scheme
     (define (scale-tree tree factor)
       (cond ((null? tree) nil)
             ((not (pair? tree)) (* tree factor))
             (else (cons (scale-tree (car tree) factor)
                         (scale-tree (cdr tree) factor)))))

     (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
     (10 (20 (30 40) 50) (60 70))

     (define (scale-tree tree factor)
       (map (lambda (sub-tree)
              (if (pair? sub-tree)
                  (scale-tree sub-tree factor)
                  (* sub-tree factor)))
            tree))
   #+END_SRC
** 2.2.3 Sequences as Conventional Interfaces
   #+BEGIN_SRC scheme
     (define (sum-odd-squares tree)
       (cond ((null? tree) 0)
             ((not (pair? tree))
              (if (odd? tree) (square tree) 0))
             (else (+ (sum-odd-squares (car tree))
                      (sum-odd-squares (cdr tree))))))

     (define (even-fibs n)
       (define (next k)
         (if (> k n)
             '()
             (let ((f (fib k)))
               (if (even? f)
                   (cons f (next (+ k 1)))
                   (next (+ k 1)))))
         (next 0)))

   #+END_SRC
   Unfortunately, the two procedure definitions above fail to exhibit this signal-flow structure.If we could organize our programs to make the signal-flow structure manifest in the procedures we write, this would increase the conceptual clarity of the resulting code.
   
   Sequence Operations
   The key to roganizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the "signals" that flow from one stage in the process to the next.If we represent these signals as list, then we can use list operations to implement the processing at each of the stages.
   #+BEGIN_SRC scheme
     (map square (list 1 2 3 4 5))
     (1 4 9 16 25)

     (define (filter predicate sequence)
       (cond ((null? sequence) '())
             ((predicate (car sequence))
              (cons (car sequence)
                    (filter predicate (cdr sequence))))
             (else (filter predicate (cdr sequence)))))

     (define (accumulate op initial sequence)
       (if (null? sequence)
           initial
           (op (car sequence)
               (accumulate op initial (cdr sequence)))))

     (define (enumerate-interval low high)
       (if (> low high)
           '()
           (cons low (enumerate-interval (+ low 1) high))))

     (define (enumerate-tree tree)
       (cond ((null? tree) '())
             ((not (pair? tree)) (list tree))
             (else (append (enumerate-tree (car tree))
                           (enumerate-tree (cdr tree))))))
     (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
     (1 2 3 4 5)

     (define (sum-odd-squares tree)
       (accumulate
        + 0 (map square (filter odd? (enumerate-tree tree)))))

     (define (even-fibs n)
       (accumulate
        cons
        '()
        (filter even? (map fib (enumerate-interval 0 n)))))
   #+END_SRC
   The value of expressing programs as sequence operations is that this help us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces.We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways.
   #+BEGIN_SRC scheme
     (define (list-fib-squares n)
       (accumulate
        cons
        '()
        (map squaare (map fib (enumerate-interval 0 n)))))
     (list-fib-squares 10)
     (0 1 1 4 9 25 64 169 441 1156 3025)

     (define (product-of-squares-of-odd-elements sequence)
       (accumulate * 1 (map squaare (filter odd? sequence))))
     (product-of-squares-of-odd-elements (list 1 2 3 4 5))
     225
   #+END_SRC
   
   Nested Mapping
   #+BEGIN_SRC scheme
     (accumulate
      append '() (map (lambda (i)
                        (map (lambda (j) (list i j))
                             (enumerate-interval 1 (- i 1))))
                      (enumerate-interval 1 n)))

     (define (flatmap proc seq)
       (accumulate append '() (map proc seq)))

     (define (prime-sum? pair)
       (prime? (+ (car pair) (cadr pair))))

     (define (make-pair-sum pair)
       (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

     (define (prime-sum-pairs n)
       (map make-pair-sum
            (filter prime-sum? (flatmap
                                (lambda (i)
                                  (map (lambda (j) (list i j))
                                       (enumerate-interval 1 (- i 1))))
                                (enumerate-interval 1 n)))))

     (define (permutations s)
       (if (null? s)
           (list '())
           (flatmap (lambda (x)
                      (map (lambda (p) (cons x p))
                           (permutations (remove x s))))
                    s)))

     (define (remove item sequence)
       (filter (lambda (x) (not (= x item)))
               sequence))
   #+END_SRC
** 2.2.4 Example: A Picture Language
*** The picture language
    When we began our study of programming in Section 1.1, we emphasized the importance of describing a language by focusing on the language's primitives, its means of combination, and its means of abstraction.We'll follow that framework here.
    #+BEGIN_SRC scheme
      (define wave2 (beside wave (flip-vert wave)))
      (define wave4 (below wave2 wave2))

      (define (flipped-pairs painter)
        (let ((painter2 (beside painter (flip-vert painter))))
          (below painter2 painter2)))

      (define wave4 (flipped-pairs wave))

      (define (right-split painter n)
        (if (= n 0)
            painter
            (let ((smaller (right-split painter (- n 1))))
              (beside painter (below smaller smaller)))))

      (define (corner-split painter n)
        (if (= n 0)
            painter
            (let ((up (up-split painter (- n 1)))
                  (right (right-split painter (- n 1))))
              (let ((top-left (beside up up))
                    (bottom-right (below right right))
                    (corner (corner-split painter (- n 1))))
                (beside (below painter top-left)
                        (below bottom-right corner))))))

      (define (square-limit painter n)
        (let ((quarter (corner-split painter n)))
          (let ((half (beside (flip-horiz quarter) quarter)))
            (below (flip-vert half) half))))
    #+END_SRC
*** Higher-order operations
    In addition to abstracting patterns of combining painters, we can work at a higher level, abstracting patterns of combining painter operations.That is, we can view the painter operations as elements to manipulate and can write means of combination for these elements-procedures that take painter operations as arguments and create new painter operations.
    #+BEGIN_SRC scheme
      (define (square-of-four tl tr bl br)
        (lambda (painter)
          (let ((top (beside (tl painter) (tr painter)))
                (bottom (beside (bl painter) (br painter))))
            (below bottom top))))

      (define (flipped-pairs painter)
        (let ((combine4 (square-of-four identity flip-vert
                                        identity flip-vert)))
          (combine4 painter)))

      (define (square-limit painter n)
        (let ((combine4 (square-of-four flip-horiz identity
                                        rotate180 flip-vert)))
          (combine4 (corner-split painter n))))
    #+END_SRC
*** Frames
    A frame can be described by three vectors-an origin vector and two edge vectors.
    #+BEGIN_SRC scheme
      (define (frame-coord-map frame)
        (lambda (v)
          (add-vect
           (origin-frame frame)
           (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
                     (scale-vect (ycor-vect v) (edge2-frame frame))))))

      ((frame-coord-map a-frame) (make-vect 0 0))

      (origin-frame a-frame)
    #+END_SRC
*** Painters
    A painter is represented as a procedure that, given a frame as argument, draws a particular image shifted and scaled to fit the frame.
    #+BEGIN_SRC scheme
      (define (segments->painter segment-list)
        (lambda (frame)
          (for-each
           (lambda (segment)
             (draw-line
              ((frame-coord-map frame)
               (start-segment segment))
              ((frame-coord-map frame)
               (end-segment segment))))
           segment-list)))
    #+END_SRC
    Representing painters as procedures erects a powerful abstration barrier in the picture language.We can create and intermix all sorts of primitive painters, based on a variety of graphics capabilities.The details of their implementation do not matter.
*** Transforming and combining painter
    Thus, for example, flip-vert doesn't have to know how a painter works in order to flip it-it just has to know how to turn a frame upside down:The flipped painter just uses the original painter, but in the inverted frame.
    #+BEGIN_SRC scheme
      (define (transform-painter painter origin corner1 corner2)
        (lambda (frame)
          (let ((m (frame-coord-map frame)))
            (let ((new-origin (m origin)))
              (painter (make-frame
                        new-origin
                        (sub-vect (m corner1) new-origin)
                        (sub-vect (m corner2) new-origin)))))))

      (define (flip-vert painter)
        (transform-painter painter
                           (make-vect 0.0 1.0) ; new origin
                           (make-vect 1.0 1.0) ; new end of edge1
                           (make-vect 0.0 0.0))) ; new end of edge2

      (define (shrink-to-upper-right painter)
        (transform-painter
         painter (make-vect 0.5 0.5)
         (make-vect 1.0 0.5) (make-vect 0.5 1.0)))

      (define (rotate90 painter)
        (transform-painter painter
                           (make-vect 1.0 0.0)
                           (make-vect 1.0 1.0)
                           (make-vect 0.0 0.0)))

      (define (squash-inwards painter)
        (transform-painter painter
                           (make-vect 0.0 0.0)
                           (make-vect 0.65 0.35)
                           (make-vect 0.35 0.65)))
    #+END_SRC
    Frame transformation is also the key to defining means of combining two or more painters.
    #+BEGIN_SRC scheme
      (define (beside painter1 painter2)
        (let ((split-point (make-vect 0.5 0.0)))
          (let ((paint-left
                 (transform-painter
                  painter1
                  (make-vect 0.0 0.0)
                  split-point
                  (make-vect 0.0 1.0)))
                (paint-right
                 (transform-painter
                  painter2
                  split-point
                  (make-vect 1.0 0.0)
                  (make-vect 0.5 1.0))))
            (lambda (frame)
              (paint-left frame)
              (paint-right frame)))))
    #+END_SRC
    The beside procedure need not know anything about the details of the component painters other than that each painter will draw something in its designated frame.
*** Levels of language for robust design
    The means of combination satisfy the closure property, which permits us to easily build up complex designs.Finally, all the tools for abstracting procedures are available to us for abstracting means of combination for painters.
    This is approach of *statified design*, the notion that a complex system should be structured as a sequence of levels that are described using a sequence of languages.Each level is constructed by combining parts that are regarded as primitives at the next level.
    Stratified design helps make program *robust*, that is, it makes it likely that small changes in a specification will require correspondingly small changes in the program
* 2.3 Sybolic Data
  In this section we extend the presentational capability of our language by introducing the ability to work with arbitrary symbols as data.
** 2.3.1 Quatation
   In order to manipulate symbols we need a new element in our language: the ability to *quote* a data object. 
   #+BEGIN_SRC scheme
     (define a 1)

     (define b 2)

     (list a b)
     (1 2)

     (list 'a 'b)
     (a b)

     (list 'a b)
     (a 2)

     (car '(a b c))
     a

     (cdr '(a b c))
     (b c)

     (define (memq item x)
       (cond ((null? x) false)
             ((eq? item (car x) x))
             (else (memq item (cdr x)))))

     (memq 'apple '(pear banana prune))
     false

     (memq 'apple '(x (apple sauce) y apple pear))
     (apple pear)
   #+END_SRC
** 2.3.2 Example: Symbolic Differentiation
   We would lick the procedure to take as arguments an algebraic expression and a variable and to return the derivative of the expression with respect to the variable.
*** The differentiation program with abstract data 
    #+BEGIN_SRC scheme
      (variable? e) ;; Is e a variable?
      (same-vaiable? v1 v2) ;; Are v1 and v2 the same variable?
      (sum? e) ;; Is e a sum?
      (addend e) ;; Addend of the sum e.
      (augend e) ;; Augend of the sum e.
      (make-sum a1 a2) ;; Construct the sum of a1 and a2.
      (product? e) ;; Is e a product?
      (multiplier e) ;; Multiplier of the product e.
      (multiplicand e) ;; Multiplicand of the product e.
      (make-product m1 m2) ;; Construct the product of m1 and m2.

      (define (deriv exp var)
        (cond ((number? exp) 0)
              ((variable? exp) (if (same-vaiable? exp var)
                                   1
                                   0))
              ((sum? exp) (make-sum (deriv (addend exp) var)
                                    (deriv (augend exp) var)))
              ((product? exp)
               (make-sum
                (make-product (multiplier exp)
                              (deriv (multiplicand exp) var))
                (make-product (multiplicand exp)
                              (deriv (multiplier exp) var))))
              (else
               (error "unknown expression type: DERIV" exp))))
    #+END_SRC
    This *deriv* procedure incorporates the complete differentiation algorithm. Since it is expressed in terms of abstract data, it will work no matter how we choose to represent algebraic expressions, as long as we design a proper set of selectors and constructors.
*** Representing algebraic expressions
    However, one especially straightforward choice is to use the same parenthesized prefix notation that Lisp uses for combinations; that is, to represent ax + b as (+ (* a x) b). 
    #+BEGIN_SRC scheme
      (define (variable? x) (symbol? x))

      (define (same-variable? v1 v2)
        (and (variable? v1)
             (variable? v2)
             (eq? v1 v2)))

      (define (make-sum a1 a2)
        (list '+ a1 a2))

      (define (make-product m1 m2)
        (list '* m1 m2))

      (define (sum? x)
        (and (pair? x)
             (eq? (car x) '+)))

      (define (addend s)
        (cadr s))

      (define (augend s)
        (caddr s))

      (define (product? x)
        (and (pair? x)
             (eq? (car x) '*)))

      (define (multiplier p)
        (cadr p))

      (define (multiplicand p)
        (caddr p))
    #+END_SRC
    To accomplish the rational-number reduction, we needed to change only the constructors and the selectors of the implementation.
    #+BEGIN_SRC scheme
      (define (make-sum a1 a2)
        (cond ((=number? a1 0) a2)
              ((=number? a2 0) a1)
              ((and (number? a1) (number? a2))
               (+ a1 a2))
              (else (list '+ a1 a2))))

      (define (=number? exp num)
        (and (number? exp)
             (= exp num)))

      (define (make-product m1 m2)
        (cond ((or (=number? m1 0) (=number? m2)) 0)
              ((=number? m1 1) m2)
              ((=number? m2 1) m1)
              ((and (number? m1) (number? m2))
               (* m1 m2))
              (else (list '* m1 m2))))
    #+END_SRC
** 2.3.2 Example: Representing Sets
   That is, we define "set" by specifying the operations that are to be used on sets.These are *union-set*, *intersection-set*, *element-of-set?*, and *adjoin-set*.
*** Sets as unordered lists
    #+BEGIN_SRC scheme
      (define (element-of-set? x set)
        (cond ((null? set) false)
              ((equal? x (car set)) true)
              (else (element-of-set? x (cdr set)))))

      (define (adjoin-set x set)
        (if (element-of-set? x set)
            set
            (cons x set)))

      (define (intersection-set set1 set2)
        (cond ((or (null? set1) (null? set2)) '())
              ((element-of-set? (car set1) set2)
               (cons (car set1) (intersection-set (cdr set1) set2)))
              (else (intersection-set (cdr set1) set2))))
    #+END_SRC
*** Sets as ordered lists
    #+BEGIN_SRC scheme
      (define (element-of-set? x set)
        (cond ((null? set) false)
              ((= x (car set)) true)
              ((< x (car set)) false)
              (else (element-of-set? x (cdr set)))))

      (define (intersection-set set1 set2)
        (if (or (null? set1) (null? set2))
            '()
            (let ((x1 (car set1)) (x2 (car set2)))
              (cond ((= x1 x2)
                     (cons x1 (intersection-set (cdr set1)
                                                (cdr set2))))
                    ((< x1 x2)
                     (intersection-set (cdr set1) set2))
                    ((< x2 x1)
                     (intersection-set set1 (cdr set2)))))))
    #+END_SRC
*** Sets as binary trees
    #+BEGIN_SRC scheme
      (define (make-tree entry left right)
        (list entry left right))

      (define (entry tree)
        (car tree))

      (define (left-branch tree)
        (cadr tree))

      (define (right-branch tree)
        (caddr tree))

      (define (element-of-set? x set)
        (cond ((null? set) false)
              ((= x (entry set)) true)
              ((< x (entry set))
               (element-of-set? x (left-branch set)))
              ((> x (entry set))
               (element-of-set? x (right-branch set)))))

      (define (adjoin-set x set)
        (cond ((null? set) (make-tree x '() '()))
              ((= x (entry set))
               set)
              ((< x (entry set))
               (make-tree (entry set)
                          (adjoin-set x (left-branch set))
                          (right-branch set)))
              ((> x (entry set))
               (make-tree (entry set)
                          (left-branch set)
                          (adjoin-set x (right-branch set))))))
    #+END_SRC
*** Sets and information retrieval
    #+BEGIN_SRC scheme
      (define (lookup given-key set-of-records)
        (cond ((null? set-of-records) false)
              ((equal? given-key (key (car set-of-records)))
               (car set-of-records))
              (else (lookup given-key (cdr set-of-records)))))

    #+END_SRC

